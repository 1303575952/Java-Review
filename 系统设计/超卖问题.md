# 超卖问题

1.不同用户在读请求的时候，发现商品库存足够，然后同时发起请求，进行秒杀操作，减库存，导致库存减为负数。

2.同一个用户在有库存的时候，连续发出多个请求，两个请求同时存在，于是生成多个订单。

对于第一种超卖现象;

(1)最简单的方法，更新数据库减库存的时候，进行库存限制条件，

update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId} and stock_count >0
可以简单的解决超卖的情况，但是不能完全避免；

(2)究其深层原因，是因为数据库底层的写操作和读操作可以同时进行，虽然写操作默认带有隐式锁（即对同一数据不能同时进行写操作）但是读操作默认是不带锁的，所以当用户1去修改库存的时候，用户2依然可以都到库存为1，所以出现了超卖现象。

解决方案：

可以对读操作加上显式锁（即在select ...语句最后加上for update）这样一来用户1在进行读操作时用户2就需要排队等待了

但是问题来了，如果该商品很热门并发量很高那么效率就会大大的下降，怎么解决？

解决方案：

我们可以有条件有选择的在读操作上加锁，比如可以对库存做一个判断，当库存小于一个量时开始加锁，让购买者排队，这样一来就解决了超卖现象。

（3）应用一个队列缓存，将多线程变为单线程读写。

 2.第二种现象，将userId和商品Id 加上唯一索引，可以解决这种情况。插入失败。
